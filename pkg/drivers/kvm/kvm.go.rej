diff a/pkg/drivers/kvm/kvm.go b/pkg/drivers/kvm/kvm.go	(rejected hunks)
@@ -141,11 +141,11 @@ func (d *Driver) GetURL() (string, error) {
 func (d *Driver) PreCommandCheck() error {
 	conn, err := getConnection(d.ConnectionURI)
 	if err != nil {
-		return errors.Wrap(err, "getting libvirt connection")
+		return fmt.Errorf("failed opening libvirt connection: %w", err)
 	}
 	defer func() {
 		if _, err := conn.Close(); err != nil {
-			log.Errorf("unable to close libvirt connection: %v", err)
+			log.Errorf("failed closing libvirt connection: %v", lvErr(err))
 		}
 	}()
 
@@ -167,7 +167,7 @@ func (d *Driver) GetState() (state.State, error) {
 	}
 	defer func() {
 		if err := closeDomain(dom, conn); err != nil {
-			log.Errorf("unable to close domain: %v", err)
+			log.Errorf("failed closing domain: %v", err)
 		}
 	}()
 
@@ -225,11 +225,11 @@ func (d *Driver) GetIP() (string, error) {
 
 	conn, err := getConnection(d.ConnectionURI)
 	if err != nil {
-		return "", errors.Wrap(err, "getting libvirt connection")
+		return "", fmt.Errorf("failed opening libvirt connection: %w", err)
 	}
 	defer func() {
 		if _, err := conn.Close(); err != nil {
-			log.Errorf("unable to close libvirt connection: %v", err)
+			log.Errorf("failed closing libvirt connection: %v", lvErr(err))
 		}
 	}()
 
@@ -265,7 +265,7 @@ func (d *Driver) Kill() error {
 	}
 	defer func() {
 		if err := closeDomain(dom, conn); err != nil {
-			log.Errorf("unable to close domain: %v", err)
+			log.Errorf("failed closing domain: %v", err)
 		}
 	}()
 
@@ -303,17 +303,47 @@ func (d *Driver) Start() error {
 	}
 	defer func() {
 		if err := closeDomain(dom, conn); err != nil {
-			log.Errorf("unable to close domain: %v", err)
+			log.Errorf("failed closing domain: %v", err)
+		}
+	}()
+
+	domXML, err := dom.GetXMLDesc(libvirt.DOMAIN_XML_SECURE)
+	if err != nil {
+		log.Debugf("failed to get domain XML: %v", lvErr(err))
+	} else {
+		log.Debugf("starting domain XML:\n%s", domXML)
+	}
+
+	// libvirt/qemu creates a console log file owned by root:root and permissions 0600,
+	// so we pre-create it (and close it immediately), just to be able to read it later
+	logPath := consoleLogPath(*d)
+	f, err := os.Create(logPath)
+	if err != nil {
+		log.Debugf("failed to create console log file %q: %v", logPath, err)
+	} else {
+		f.Close()
+	}
+	// ensure console log file is cleaned up
+	defer func() {
+		if _, err := os.Stat(logPath); err == nil {
+			if err := os.Remove(logPath); err != nil {
+				log.Debugf("failed removing console log file %q: %v", logPath, err)
+			}
 		}
 	}()
 
-	log.Info("creating domain...")
 	if err := dom.Create(); err != nil {
 		return errors.Wrap(err, "creating domain")
 	}
 
+	log.Info("waiting for domain to start...")
+	if err := d.waitForDomainState(state.Running, 30*time.Second); err != nil {
+		return errors.Wrap(err, "waiting for domain to start")
+	}
+	log.Info("domain is now running")
+
 	log.Info("waiting for IP...")
-	if err := d.waitForStaticIP(conn); err != nil {
+	if err := d.waitForStaticIP(conn, 90*time.Second); err != nil {
 		return errors.Wrap(err, "waiting for IP")
 	}
 
@@ -325,8 +355,51 @@ func (d *Driver) Start() error {
 	return nil
 }
 
+// consoleLogPath returns the path to the console log file for the given machine name.
+func consoleLogPath(d Driver) string {
+	// return fmt.Sprintf("%s-console.log", machineName)
+	return d.ResolveStorePath("console.log")
+}
+
+// waitForDomainState waits maxTime for the domain to reach a target state.
+func (d *Driver) waitForDomainState(targetState state.State, maxTime time.Duration) error {
+	query := func() error {
+		currentState, err := d.GetState()
+		if err != nil {
+			return fmt.Errorf("failed getting domain state: %w", err)
+		}
+
+		if currentState == targetState {
+			return nil
+		}
+
+		log.Debugf("current domain state is %q, will retry", currentState.String())
+		return fmt.Errorf("last domain state: %q", currentState.String())
+	}
+	if err := retry.Local(query, maxTime); err != nil {
+		dumpConsoleLogs(consoleLogPath(*d))
+		return fmt.Errorf("timed out waiting %v for domain to reach %q state: %w", maxTime, targetState.String(), err)
+	}
+	return nil
+}
+
+// dumpConsoleLogs prints out the console log.
+func dumpConsoleLogs(logPath string) {
+	if _, err := os.Stat(logPath); err != nil {
+		log.Debugf("failed checking console log file %q: %v", logPath, err)
+		return
+	}
+
+	data, err := os.ReadFile(logPath)
+	if err != nil {
+		log.Debugf("failed dumping console log file %q: %v", logPath, err)
+		return
+	}
+	log.Debugf("console log:\n%s", data)
+}
+
 // waitForStaticIP waits for IP address of domain that has been created & starting and then makes that IP static.
-func (d *Driver) waitForStaticIP(conn *libvirt.Connect) error {
+func (d *Driver) waitForStaticIP(conn *libvirt.Connect, maxTime time.Duration) error {
 	query := func() error {
 		sip, err := ipFromAPI(conn, d.MachineName, d.PrivateNetwork)
 		if err != nil {
@@ -342,8 +415,9 @@ func (d *Driver) waitForStaticIP(conn *libvirt.Connect) error {
 
 		return nil
 	}
-	if err := retry.Local(query, 1*time.Minute); err != nil {
-		return fmt.Errorf("domain %s didn't return IP after 1 minute", d.MachineName)
+	if err := retry.Local(query, maxTime); err != nil {
+		dumpConsoleLogs(consoleLogPath(*d))
+		return fmt.Errorf("domain %s didn't return IP after %v", d.MachineName, maxTime)
 	}
 
 	log.Info("reserving static IP address...")
@@ -358,7 +432,7 @@ func (d *Driver) waitForStaticIP(conn *libvirt.Connect) error {
 
 // Create a host using the driver's config
 func (d *Driver) Create() error {
-	log.Info("creating KVM machine...")
+	log.Info("creating domain...")
 
 	log.Info("creating network...")
 	if err := d.createNetwork(); err != nil {
@@ -418,15 +492,16 @@ func (d *Driver) Create() error {
 		log.Errorf("unable to ensure permissions on %s: %v", store, err)
 	}
 
-	log.Info("creating domain...")
-
-	dom, err := d.createDomain()
+	log.Info("defining domain...")
+	dom, err := d.defineDomain()
 	if err != nil {
-		return errors.Wrap(err, "creating domain")
+		return errors.Wrap(err, "defining domain")
 	}
 	defer func() {
-		if err := dom.Free(); err != nil {
-			log.Errorf("unable to free domain: %v", err)
+		if dom == nil {
+			log.Warnf("nil domain, cannot free")
+		} else if err := dom.Free(); err != nil {
+			log.Errorf("failed freeing %s domain: %v", d.MachineName, lvErr(err))
 		}
 	}()
 
@@ -434,7 +509,7 @@ func (d *Driver) Create() error {
 		return errors.Wrap(err, "starting domain")
 	}
 
-	log.Infof("KVM machine creation complete")
+	log.Infof("domain creation complete")
 	return nil
 }
 
@@ -470,28 +545,29 @@ func ensureDirPermissions(store string) error {
 
 // Stop a host gracefully or forcefully otherwise.
 func (d *Driver) Stop() error {
+	log.Info("stopping domain...")
+
 	s, err := d.GetState()
 	if err != nil {
-		return errors.Wrap(err, "getting domain state")
+		return fmt.Errorf("getting domain state: %w", err)
 	}
 
 	if s == state.Stopped {
+		log.Info("domain already stopped, nothing to do")
 		return nil
 	}
 
-	log.Info("stopping domain...")
-
 	dom, conn, err := d.getDomain()
 	if err != nil {
-		return errors.Wrap(err, "getting domain")
+		return fmt.Errorf("getting domain: %w", err)
 	}
 	defer func() {
 		if err := closeDomain(dom, conn); err != nil {
-			log.Errorf("unable to close domain: %v", err)
+			log.Errorf("failed closing domain: %v", err)
 		}
 	}()
 
-	log.Info("gracefully shutting down domain...")
+	log.Info("gracefully shutting domain down...")
 
 	// ref: https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainShutdownFlags
 	// note: "The order in which the hypervisor tries each shutdown method is undefined, and a hypervisor is not required to support all methods."
@@ -508,52 +584,25 @@ func (d *Driver) Stop() error {
 	}
 
 	if err := dom.Shutdown(); err != nil {
-		return errors.Wrap(err, "gracefully shutting down domain")
+		return fmt.Errorf("gracefully shutting domain down: %w", err)
 	}
 
-	if s, err = d.waitForStopState(90, "graceful shutdown"); err == nil {
-		log.Info("domain gracefully shutdown")
+	if err = d.waitForDomainState(state.Stopped, 90*time.Second); err == nil {
+		log.Info("domain gracefully shut down")
 		return nil
 	}
 
-	// could not get domain state
-	if s == state.None {
-		return err
-	}
+	log.Warn("failed graceful domain shut down, will try to force-stop")
 
-	// at this point shutdown failed, so we try with a little bit of force
-	log.Warn("waiting for domain graceful shutdown failed, will try to force-stop")
 	if err := d.Kill(); err != nil {
-		log.Warnf("force-stopping domain request failed: %v", err)
-	}
-
-	if s, err := d.waitForStopState(30, "force-stop"); err != nil {
-		return fmt.Errorf("unable to stop domain %s, current state is %q", d.MachineName, s.String())
+		return fmt.Errorf("force-stopping domain request failed: %w", err)
 	}
 
-	log.Info("domain force-stopped")
-
-	return nil
-}
-
-// waitForStopState waits maxsec for the domain to reach a stopped state.
-func (d *Driver) waitForStopState(maxsec int, method string) (state.State, error) {
-	var s state.State
-	var err error
-	for i := 0; i < maxsec; i++ {
-		if s, err = d.GetState(); err != nil {
-			return s, errors.Wrap(err, "getting domain state")
-		}
-
-		if s == state.Stopped {
-			return state.Stopped, nil
-		}
-
-		log.Infof("waiting for domain %s %d/%d", method, i, maxsec)
-		time.Sleep(1 * time.Second)
+	if err = d.waitForDomainState(state.Stopped, 30*time.Second); err == nil {
+		log.Info("domain force-stopped")
+		return nil
 	}
-
-	return s, fmt.Errorf("timed out waiting for domain %s, current state is %q", method, s)
+	return fmt.Errorf("unable to stop domain: %w", err)
 }
 
 // Remove a host
@@ -562,11 +611,11 @@ func (d *Driver) Remove() error {
 
 	conn, err := getConnection(d.ConnectionURI)
 	if err != nil {
-		return errors.Wrap(err, "getting libvirt connection")
+		return fmt.Errorf("failed opening libvirt connection: %w", err)
 	}
 	defer func() {
 		if _, err := conn.Close(); err != nil {
-			log.Errorf("unable to close libvirt connection: %v", err)
+			log.Errorf("failed closing libvirt connection: %v", lvErr(err))
 		}
 	}()
 
